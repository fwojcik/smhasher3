/*
 * mulxp_hash
 * Copyright 2020-2022 Peter Dimov
 * Copyright (C) 2025 Frank J. T. Wojcik
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and
 * to prepare derivative works of the Software, and to permit third-parties
 * to whom the Software is furnished to do so, all subject to the
 * following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole or
 * in part, and all derivative works of the Software, unless such copies or
 * derivative works are solely in the form of machine-executable object
 * code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 * WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#include "Platform.h"
#include "Hashlib.h"
#include "Mathmult.h"

//------------------------------------------------------------
// Utility functions

FORCE_INLINE uint64_t mulx( uint64_t x, uint64_t y ) {
    uint64_t r, r2;

    MathMult::mult64_128(r, r2, x, y);
    return r ^ r2;
}

inline uint64_t mul32( uint32_t x, uint32_t y ) {
    return (uint64_t)x * y;
}

template <bool bswap>
inline uint64_t read64le( unsigned char const * p ) {
    uint64_t r = GET_U64<bswap>(p, 0);

    return r;
}

template <bool bswap>
inline uint32_t read32le( unsigned char const * p ) {
    uint32_t r = GET_U32<bswap>(p, 0);

    return r;
}

//------------------------------------------------------------
// mulxp1, 32-bit

template <bool bswap>
inline uint32_t mulxp1_hash32( unsigned char const * p, size_t n, uint64_t seed ) {
    uint32_t const q = 0x9e3779b9U;
    uint32_t const k = q * q;

    uint64_t h       = (seed + q) * k;
    uint32_t w       = (uint32_t)h;

    h ^= n;

    while (n >= 4) {
        uint32_t v1 = read32le<bswap>(p);

        w += q;
        h ^= mul32(v1 + w, k);

        p += 4;
        n -= 4;
    }

    {
        uint32_t v1 = 0;

        if (n >= 1) {
            size_t const x1 = (n - 1) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;      // 1: 0, 2: 1, 3: 1

            v1 = (uint32_t)p[x1] << x1 * 8 | (uint32_t)p[x2] << x2 * 8 | (uint32_t)p[0];
        }

        w += q;
        h ^= mul32(v1 + w, k);
    }

    w += q;
    h ^= mul32((uint32_t)h + w, (uint32_t)(h >> 32) + w + k);

    return (uint32_t)h ^ (uint32_t)(h >> 32);
}

//------------------------------------------------------------
// mulxp1, 64-bit

template <bool bswap>
inline uint64_t mulxp1_hash( unsigned char const * p, size_t n, uint64_t seed ) {
    uint64_t const q = UINT64_C(0x9e3779b97f4a7c15);
    uint64_t const k = q * q;

    uint64_t w       = mulx(seed + q, k);
    uint64_t h       = w ^ n;

    while (n >= 8) {
        uint64_t v1 = read64le<bswap>(p);

        w += q;
        h ^= mulx(v1 + w, k);

        p += 8;
        n -= 8;
    }

    {
        uint64_t v1 = 0;

        if (n >= 4) {
            v1 = (uint64_t)read32le<bswap>(p + n - 4) << (n - 4) * 8 | read32le<bswap>(p);
        } else if (n >= 1)   {
            size_t const x1 = (n - 1) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;      // 1: 0, 2: 1, 3: 1

            v1 = (uint64_t)p[x1] << x1 * 8 | (uint64_t)p[x2] << x2 * 8 | (uint64_t)p[0];
        }

        w += q;
        h ^= mulx(v1 + w, k);
    }

    return mulx(h + w, k);
}

//------------------------------------------------------------
// mulxp3, 32-bit

template <bool bswap>
inline uint32_t mulxp3_hash32( unsigned char const * p, size_t n, uint64_t seed ) {
    uint32_t const q = 0x9e3779b9U;
    uint32_t const k = q * q;

    uint64_t h       = (seed + q) * k;
    uint32_t w       = (uint32_t)h;

    h ^= n;

    while (n >= 8) {
        uint32_t v1 = read32le<bswap>(p + 0);
        uint32_t v2 = read32le<bswap>(p + 4);

        w += q;
        h ^= mul32(v1 + w, v2 + w + k);

        p += 8;
        n -= 8;
    }

    {
        uint32_t v1 = 0;
        uint32_t v2 = 0;

        if (n >= 4) {
            v1 = read32le<bswap>(p);
            v2 = ((uint64_t)read32le<bswap>(p + n - 4) << (n - 4) * 8) >> 32;
        } else if (n >= 1)   {
            size_t const x1 = (n - 1) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;      // 1: 0, 2: 1, 3: 1

            v1 = (uint32_t)p[x1] << x1 * 8 | (uint32_t)p[x2] << x2 * 8 | (uint32_t)p[0];
        }

        w += q;
        h ^= mul32(v1 + w, v2 + w + k);
    }

    w += q;
    h ^= mul32((uint32_t)h + w, (uint32_t)(h >> 32) + w + k);

    return (uint32_t)h ^ (uint32_t)(h >> 32);
}

//------------------------------------------------------------
// mulxp3, 64-bit

template <bool bswap>
inline uint64_t mulxp3_hash( unsigned char const * p, size_t n, uint64_t seed ) {
    uint64_t const q = 0x9e3779b97f4a7c15ULL;
    uint64_t const k = q * q;

    uint64_t w       = mulx(seed + q, k);
    uint64_t h       = w ^ n;

    while (n >= 16) {
        uint64_t v1 = read64le<bswap>(p + 0);
        uint64_t v2 = read64le<bswap>(p + 8);

        w += q;
        h ^= mulx(v1 + w, v2 + w + k);

        p += 16;
        n -= 16;
    }

    {
        uint64_t v1 = 0;
        uint64_t v2 = 0;

        if (n > 8) {
            v1 = read64le<bswap>(p        );
            v2 = read64le<bswap>(p + n - 8) >> (16 - n) * 8;
        } else if (n >= 4)   {
            v1 = (uint64_t)read32le<bswap>(p + n - 4) << (n - 4) * 8 | read32le<bswap>(p);
        } else if (n >= 1)   {
            size_t const x1 = (n - 1) & 2; // 1: 0, 2: 0, 3: 2
            size_t const x2 = n >> 1;      // 1: 0, 2: 1, 3: 1

            v1 = (uint64_t)p[x1] << x1 * 8 | (uint64_t)p[x2] << x2 * 8 | (uint64_t)p[0];
        }

        w += q;
        h ^= mulx(v1 + w, v2 + w + k);
    }

    return mulx(h, k);
}

//------------------------------------------------------------

template <bool bswap>
static void mulxp1_32( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint32_t hash = mulxp1_hash32<bswap>((const unsigned char *)in, len, (uint64_t)seed);

    PUT_U32<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp1_64( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint64_t hash = mulxp1_hash<bswap>((const unsigned char *)in, len, (uint64_t)seed);

    PUT_U64<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp3_32( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint32_t hash = mulxp3_hash32<bswap>((const unsigned char *)in, len, (uint64_t)seed);

    PUT_U32<bswap>(hash, (uint8_t *)out, 0);
}

template <bool bswap>
static void mulxp3_64( const void * in, const size_t len, const seed_t seed, void * out ) {
    uint64_t hash = mulxp3_hash<bswap>((const unsigned char *)in, len, (uint64_t)seed);

    PUT_U64<bswap>(hash, (uint8_t *)out, 0);
}

//------------------------------------------------------------
REGISTER_FAMILY(mulxp,
   $.src_url    = "https://github.com/pdimov/mulxp_hash",
   $.src_status = HashFamilyInfo::SRC_STABLEISH
 );

REGISTER_HASH(mulxp1_hash32,
   $.desc            = "mulxp1_hash, 32-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY              ,
   $.bits            = 32,
   $.verification_LE = 0x59CBE0F0,
   $.verification_BE = 0x13253F14,
   $.hashfn_native   = mulxp1_32<false>,
   $.hashfn_bswap    = mulxp1_32<true>
 );

REGISTER_HASH(mulxp1_hash,
   $.desc            = "mulxp1_hash, 64-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY_64_64        ,
   $.bits            = 64,
   $.verification_LE = 0xA476BA89,
   $.verification_BE = 0xA2443FAE,
   $.hashfn_native   = mulxp1_64<false>,
   $.hashfn_bswap    = mulxp1_64<true>
 );

REGISTER_HASH(mulxp3_hash32,
   $.desc            = "mulxp3_hash, 32-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY              ,
   $.bits            = 32,
   $.verification_LE = 0x8C944400,
   $.verification_BE = 0x2B053E73,
   $.hashfn_native   = mulxp3_32<false>,
   $.hashfn_bswap    = mulxp3_32<true>
 );

REGISTER_HASH(mulxp3_hash,
   $.desc            = "mulxp3_hash, 64-bit version",
   $.hash_flags      =
         FLAG_HASH_ENDIAN_INDEPENDENT,
   $.impl_flags      =
         FLAG_IMPL_CANONICAL_LE          |
         FLAG_IMPL_LICENSE_BOOST         |
         FLAG_IMPL_MULTIPLY_64_64        ,
   $.bits            = 64,
   $.verification_LE = 0xB4786096,
   $.verification_BE = 0x0F21A9C4,
   $.hashfn_native   = mulxp3_64<false>,
   $.hashfn_bswap    = mulxp3_64<true>
 );
