/*
 * SMHasher3
 * Copyright (C) 2021-2022  Frank J. T. Wojcik
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see
 * <https://www.gnu.org/licenses/>.
 *
 * This file incorporates work covered by the following copyright and
 * permission notice:
 *
 *     Copyright (c) 2010-2012 Austin Appleby
 *     Copyright (c) 2015      Paul G
 *     Copyright (c) 2015-2021 Reini Urban
 *     Copyright (c) 2016      Vlad Egorov
 *     Copyright (c) 2019-2020 Yann Collet
 *     Copyright (c) 2020      Bradley Austin Davis
 *     Copyright (c) 2020      Paul Khuong
 *     Copyright (c) 2021      Jim Apple
 *     Copyright (c) 2021      Ori Livneh
 *
 *     Permission is hereby granted, free of charge, to any person
 *     obtaining a copy of this software and associated documentation
 *     files (the "Software"), to deal in the Software without
 *     restriction, including without limitation the rights to use,
 *     copy, modify, merge, publish, distribute, sublicense, and/or
 *     sell copies of the Software, and to permit persons to whom the
 *     Software is furnished to do so, subject to the following
 *     conditions:
 *
 *     The above copyright notice and this permission notice shall be
 *     included in all copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *     OTHER DEALINGS IN THE SOFTWARE.
 */
#include "Platform.h"

#include <vector>
#include <algorithm>
#include <math.h>

#include "Stats.h"

//-----------------------------------------------------------------------------

double CalcMean( std::vector<double> & v ) {
    const size_t sz   = v.size();
    double       mean = 0;

    for (size_t i = 0; i < sz; i++) {
        mean += v[i];
    }

    mean /= double(sz);

    return mean;
}

double CalcMean( std::vector<double> & v, int a, int b ) {
    double mean = 0;

    for (int i = a; i <= b; i++) {
        mean += v[i];
    }

    mean /= (b - a + 1);

    return mean;
}

double CalcStdv( std::vector<double> & v, int a, int b ) {
    double mean = CalcMean(v, a, b);

    double stdv = 0;

    for (int i = a; i <= b; i++) {
        double x = v[i] - mean;

        stdv += x * x;
    }

    stdv = sqrt(stdv / (b - a + 1));

    return stdv;
}

double CalcStdv( std::vector<double> & v ) {
    return CalcStdv(v, 0, v.size() - 1);
}

// Return true if the largest value in v[0,len) is more than three
// standard deviations from the mean

bool ContainsOutlier( std::vector<double> & v, size_t len ) {
    double mean = 0;

    for (size_t i = 0; i < len; i++) {
        mean += v[i];
    }

    mean /= double(len);

    double stdv = 0;

    for (size_t i = 0; i < len; i++) {
        double x = v[i] - mean;
        stdv += x * x;
    }

    stdv = sqrt(stdv / double(len));

    double cutoff = mean + stdv * 3;

    return v[len - 1] > cutoff;
}

// Do a binary search to find the largest subset of v that does not contain
// outliers.

void FilterOutliers( std::vector<double> & v ) {
    std::sort(v.begin(), v.end());

    size_t       len = 0;
    const size_t sz  = v.size();

    for (size_t x = 0x40000000; x; x = x >> 1) {
        if ((len | x) >= sz) { continue; }

        if (!ContainsOutlier(v, len | x)) {
            len |= x;
        }
    }

    if (len) {
        v.resize(len);
    }
}

#if 0
// Iteratively tighten the set to find a subset that does not contain
// outliers. I'm not positive this works correctly in all cases.

void FilterOutliers2( std::vector<double> & v ) {
    std::sort(v.begin(), v.end());

    int a = 0;
    int b = (int)(v.size() - 1);

    for (int i = 0; i < 10; i++) {
        // printf("%d %d\n",a,b);

        double mean = CalcMean(v, a, b);
        double stdv = CalcStdv(v, a, b);

        double cutA = mean - stdv * 3;
        double cutB = mean + stdv * 3;

        while ((a < b) && (v[a] < cutA)) { a++; }
        while ((b > a) && (v[b] > cutB)) { b--; }
    }

    std::vector<double> v2;

    v2.insert(v2.begin(), v.begin() + a, v.begin() + b + 1);

    v.swap(v2);
}

#endif

//-----------------------------------------------------------------------------

double chooseK( int n, int k ) {
    if (k > (n - k)) { k = n - k; }

    double c = 1;

    for (int i = 0; i < k; i++) {
        double t = double(n - i) / double(i + 1);

        c *= t;
    }

    return c;
}

double chooseUpToK( int n, int k ) {
    double c = 0;

    for (int i = 1; i <= k; i++) {
        c += chooseK(n, i);
    }

    return c;
}

//-----------------------------------------------------------------------------
// Different ways of estimating collision counts across N numbers,
// each of which is i.i.d. distributed across M bins.
//
// Note: with 32bit 77163 keys will get a 50% probability of one collision.

// Naive multiplication, no accuracy at all
static double ExpectedNBCollisions_Slow( const double nbH, const double nbBits ) {
    long        balls  = nbH;
    long double bins   = nbBits;
    long double result = 1.0;

    for (long i = 1; i < balls / 2; i++) {
        // take a pair from the front and the end to minimize errors
        result *= ((bins - i) / bins) * ((bins - (nbH - i)) / bins);
    }
    return (double)(nbH * result);
}

// Still too inaccurate: https://preshing.com/20110504/hash-collision-probabilities/
static double EstimateNbCollisions_Taylor( const double nbH, const double nbBits ) {
    const long double k = nbH;
    const long double b = nbBits;

    return (double)(k * (1.0 - expl(-0.5 * k * (k - 1.0) / b)));
}

// demerphq: (double(count) * double(count-1)) / pow(2.0,double(sizeof(hashtype) * 8 + 1));
// the very same as our calc. pow 2 vs exp2. Just the high cutoff is missing here.
static double EstimateNbCollisions_Demerphq( const double nbH, const double nbBits ) {
    return (nbH * (nbH - 1)) / pow(2.0, nbBits + 1);
}

// The previous best calculation, highly prone to inaccuracies with low results (1.0 - 10.0)
// TODO: return also the error.
static double EstimateNbCollisions_previmpl( const double nbH, const double nbBits ) {
    double exp    = exp2(nbBits); // 2 ^ bits
    double result = (nbH * (nbH - 1)) / (2.0 * exp);

    if (result > nbH) {
        result = nbH;
    }
    // improved floating point accuracy
    if ((result <= exp) || (nbBits > 32)) {
        return result;
    }
    return result - exp;
}

static double EstimateNbCollisions_fwojcik( const double nbH, const int nbBits ) {
    // If the probability that there are 1 or more collisions (p(C >=
    // 1)) is not much higher than the probability of exactly 1
    // collision (p(C == 1)), then the classically-good approximation
    // of the probability of any collisions is also a good estimate
    // for the expected number of collisions.
    //
    // If there are 2**n buckets and 2**(n-r) hashes, then the ratio
    // of p(C >= 1)/p(C == 1) is about 1/(1-2**(n-2r-1)). This uses
    // the new estimator if that ratio is > 1 + 2**-8. That cutoff
    // minimizes the error around the values we care about.
    if (nbBits - 2.0 * log2(nbH) >= 8 - 1) {
        return nbH * (nbH - 1) * exp2(-nbBits - 1);
    }

    // The probability that any given hash bucket is empty after nbH
    // insertions is:
    //    pE     = ((2**nbBits - 1)/(2**nbBits))**nbH
    // so we compute:
    //    ln(pE) = nbH * ln((2**nbBits - 1)/(2**nbBits))
    //           = nbH * ln(1 - 1/2**(nbBits))
    //           = nbH * ln(1 - 2**(-nbBits))
    //           = nbH * ln(1 + -(2**(-nbBits)))
    // This means the probability that any given hash bucket is
    // occupied after nbH insertions is:
    //     pF = 1 - pE
    //     pF = 1 - exp(ln(pE))
    //     pF = -(exp(ln(pE)) - 1)
    //     pF = -expm1(ln(pE))
    // And the expected number of collisions is:
    //     C = m - n + n * pE
    //     C = m - n * (1 - pE)
    //     C = n * (m/n - 1 + pE)
    //     C = n * (m/n - (1 - pE))
    //     C = n * (m/n - pF)
    //     C = n * (m/n - (-expm1(ln(pE))))
    //     C = n * (m/n + expm1(ln(pE)))
    // Since the format of floats/doubles is k*2**n, multiplying by
    // exp2(x) doesn't lose any precision, and this formulation keeps
    // m/n and pF at the same general orders of magnitude, so it tends
    // to have very good precision. At low hash occupancy, pF is too
    // close to m/n for this formula to work well.
    double logpE  = (double)nbH * log1p(-exp2(-nbBits));
    double result = exp2(nbBits) * (exp2(-nbBits) * (double)nbH + expm1(logpE));

    return result;
}

double EstimateNbCollisions( const unsigned long nbH, const int nbBits ) {
    return EstimateNbCollisions_fwojcik((const double)nbH, (const double)nbBits);
}

#define COLLISION_ESTIMATORS 3

static double EstimateNbCollisionsCand( const unsigned long nbH, const int nbBits, const int estimator ) {
    switch (estimator) {
    case 0: return EstimateNbCollisions_fwojcik((const double)nbH, (const double)nbBits);
    case 1: return EstimateNbCollisions_previmpl((const double)nbH, (const double)nbBits);
    case 2: return EstimateNbCollisions_Demerphq((const double)nbH, (const double)nbBits);
    // case 3: return EstimateNbCollisions_Taylor((const double)nbH, (const double)nbBits);
    // case 4: return ExpectedNBCollisions_Slow((const double)nbH, (const double)nbBits);
    default: { printf("Invalid estimator requested\n"); exit(1); }
    }
    return NAN;
}

//-----------------------------------------------------------------------------

/*
 * This list of actual expected collision values was generated via the
 * exactcoll.c program which uses the MPFI or MPFR library to compute
 * these values with 768 bits of precision, and then post-processed
 * via strtod() to get the maximum number of digits that can fit in a
 * double.
 */
static double realcoll[58][18] = {
    /* 149633745 */
    {
        9.66830188511513408e-62, 4.15250404044246501e-52, 7.66001792990870096e-33,
        3.28995264957314909e-23, 6.06889145411344312e-04, 3.10727242021280714e-01,
        3.18184245207177412e+02, 2.54544870233834445e+03, 2.03619731305636706e+04,
        1.62792385217456205e+05, 2.57656049031511368e+06, 1.90430490019698478e+07,
        5.94342984822125658e+07, 1.32858774460385174e+08, 1.45439441000000000e+08,
        1.49109457000000000e+08, 1.49629649000000000e+08, 1.49633489000000000e+08
    },
    /* 86536545 */
    {
        3.23362916384237121e-62, 1.38883315060948101e-52, 2.56194496903768089e-33,
        1.10034698561685720e-23, 2.02978192359201898e-04, 1.03924834404869174e-01,
        1.06418943269388180e+02, 8.51346660380768071e+02, 6.81046060560096157e+03,
        5.44636796883101269e+04, 8.65959061394601478e+05, 6.61418293104189448e+06,
        2.27556140267314911e+07, 6.98558535013311207e+07, 8.23422410045954734e+07,
        8.60122570000000000e+07, 8.65324490000000000e+07, 8.65362890000000000e+07
    },
    /* 75498113 */
    {
        2.46129292104772484e-62, 1.05711726017762883e-52, 1.95003715543977527e-33,
        8.37534580859870329e-24, 1.54497860659825494e-04, 7.91029046026853616e-02,
        8.10013164325720538e+01, 6.48007286993706316e+02, 5.18385065708740240e+03,
        4.14575199616562895e+04, 6.59692186580697889e+05, 5.06817564395631664e+06,
        1.77549757986361682e+07, 5.89072678887400925e+07, 7.13038090638692677e+07,
        7.49738250000000000e+07, 7.54940170000000000e+07, 7.54978570000000000e+07
    },
    /* 56050289 */
    {
        1.35658440124283578e-62, 5.82648563760172142e-53, 1.07479689405983373e-33,
        4.61621750982936253e-24, 8.51541829923128089e-05, 4.35989416694992429e-02,
        4.46452925853961631e+01, 3.57161013077325094e+02, 2.85720313997638277e+03,
        2.28521884740198511e+04, 3.64148636055323470e+05, 2.82665629721443821e+06,
        1.02311598958176058e+07, 3.98670968021314815e+07, 5.18559915916659608e+07,
        5.55260010000000000e+07, 5.60461930000000000e+07, 5.60500330000000000e+07
    },
    /* 49925029 */
    {
        1.07628616390943998e-62, 4.62261387512834023e-53, 8.52721751060712554e-34,
        3.66241203339361373e-24, 6.75595774724252468e-05, 3.45905036499356000e-02,
        3.54206590004570572e+01, 2.83364333813803171e+02, 2.26685462770169033e+03,
        1.81309949687949847e+04, 2.89045130868813896e+05, 2.25101610920316912e+06,
        8.23359498302312009e+06, 3.40035930111785606e+07, 4.57307533941198885e+07,
        4.94007410000000000e+07, 4.99209330000000000e+07, 4.99247730000000000e+07
    },
    /* 44251425 */
    {
        8.45562327779528750e-63, 3.63166254454270828e-53, 6.69923495212561545e-34,
        2.87729950275996440e-24, 5.30768075507823733e-05, 2.71753254548965095e-02,
        2.78275216109708978e+01, 2.22619519580197675e+02, 1.78091434578536018e+03,
        1.42446392954819730e+04, 2.27182256963651860e+05, 1.77461480911257491e+06,
        6.55507402957992628e+06, 2.86743406137902029e+07, 4.00572308235341832e+07,
        4.37271370000000000e+07, 4.42473290000000000e+07, 4.42511690000000000e+07
    },
    /* 43691201 */
    {
        8.24288176206433810e-63, 3.54029075928611856e-53, 6.53068375830698963e-34,
        2.80490731624468888e-24, 5.17414074132004304e-05, 2.64916005848709717e-02,
        2.71273877811360791e+01, 2.17018473441357912e+02, 1.73610754462317163e+03,
        1.38862852138241597e+04, 2.21476017148987623e+05, 1.73055958502948540e+06,
        6.39857166559864674e+06, 2.81548679497163482e+07, 3.94970225171834230e+07,
        4.31669130000000000e+07, 4.36871050000000000e+07, 4.36909450000000000e+07
    },
    /* 33558529 */
    {
        4.86291784915122170e-63, 2.08860731252391586e-53, 3.85280045646069782e-34,
        1.65476519585125690e-24, 3.05250300699314860e-05, 1.56288153909619858e-02,
        1.60039018771892643e+01, 1.28030930083075560e+02, 1.02422920513447593e+03,
        8.19266670739054098e+03, 1.30763213462519823e+05, 1.02731598739112553e+06,
        3.86648187299589021e+06, 1.90513077430028245e+07, 2.93656306571820080e+07,
        3.30342410000000000e+07, 3.35544330000000000e+07, 3.35582730000000000e+07
    },
    /* 33554432 */
    {
        4.86173054093815170e-63, 2.08809736752937507e-53, 3.85185977398010151e-34,
        1.65436117580224877e-24, 3.05175772154867956e-05, 1.56249995294880754e-02,
        1.59999944369014884e+01, 1.27999670665119382e+02, 1.02397913646883865e+03,
        8.19066658538974480e+03, 1.30731328417170167e+05, 1.02706774802737299e+06,
        3.86557557111472497e+06, 1.90477651439465471e+07, 2.93615350309002101e+07,
        3.30301440000000000e+07, 3.35503360000000000e+07, 3.35541760000000000e+07
    },
    /* 26977161 */
    {
        3.14256005499304537e-63, 1.34971926619110914e-53, 2.48979258747824472e-34,
        1.06935777370422802e-24, 1.97261691747440925e-05, 1.00997986149531007e-02,
        1.03421911410463228e+01, 8.27373811067683533e+01, 6.61889575586005321e+02,
        5.29451037409544824e+03, 8.45461443414444802e+04, 6.66574543746769894e+05,
        2.53827383658029372e+06, 1.35603369840820655e+07, 2.27896075604615994e+07,
        2.64528730000000000e+07, 2.69730650000000000e+07, 2.69769050000000000e+07
    },
    /* 22370049 */
    {
        2.16085171788696973e-63, 9.28078745982995323e-54, 1.71200311073976113e-34,
        7.35299737127754043e-25, 1.35638860682561044e-05, 6.94470966551262447e-03,
        7.11138119182984063e+00, 5.68909651356401653e+01, 4.55122319603302856e+02,
        3.64063288968196957e+03, 5.81554370404469810e+04, 4.59645385789985245e+05,
        1.76481282635707408e+06, 1.00151462171464767e+07, 1.81959928124494441e+07,
        2.18457610000000000e+07, 2.23659530000000000e+07, 2.23697930000000000e+07
    },
    /* 18877441 */
    {
        1.53878283990836292e-63, 6.60902197305242237e-54, 1.21914936914420980e-34,
        5.23620666941341261e-25, 9.65909643476873488e-06, 4.94545737373954832e-03,
        5.06414744590625077e+00, 4.05131288488040155e+01, 3.24101784837318064e+02,
        2.59260655174234762e+03, 4.14247903550759002e+04, 3.28028082683300890e+05,
        1.26742600458991365e+06, 7.54599182152087614e+06, 1.47296973581916802e+07,
        1.83531530000000000e+07, 1.88733450000000000e+07, 1.88771850000000000e+07
    },
    /* 18616785 */
    {
        1.49658179329122305e-63, 6.42776985797483522e-54, 1.18571425534766178e-34,
        5.09260394911920045e-25, 9.39419617181328754e-06, 4.80982843914157677e-03,
        4.92526345384282216e+00, 3.94020589843511928e+01, 3.15213358531706945e+02,
        2.52150762757849679e+03, 4.02895318773614636e+04, 3.19083263398166222e+05,
        1.23344671390196425e+06, 7.37060359433948807e+06, 1.44720266633904669e+07,
        1.80924970000000000e+07, 1.86126890000000000e+07, 1.86165290000000000e+07
    },
    /* 17676661 */
    {
        1.34924729526152486e-63, 5.79497300736470505e-54, 1.06898383980911691e-34,
        4.59125063193266000e-25, 8.46936253854919755e-06, 4.33631361902940549e-03,
        4.44038440299461268e+00, 3.55230335814082565e+01, 2.84181603549241117e+02,
        2.27328227266108661e+03, 3.63257830806934944e+04, 2.87837384102243173e+05,
        1.11455845455760439e+06, 6.74926355401089974e+06, 1.35443510115238819e+07,
        1.71523730000000000e+07, 1.76725650000000000e+07, 1.76764050000000000e+07
    },
    /* 16777216 */
    {
        1.21543259901182161e-63, 5.22024326324805573e-54, 9.62964914796432828e-35,
        4.13590281624610549e-25, 7.62939407650033587e-06, 3.90624976656302669e-03,
        3.99999912579873262e+00, 3.19999574025932816e+01, 2.55997380594878024e+02,
        2.04783322146484898e+03, 3.27253730219586105e+04, 2.59434518880420335e+05,
        1.00621717678566615e+06, 6.17199266255285591e+06, 1.26597333208222985e+07,
        1.62529280000000075e+07, 1.67731200000000000e+07, 1.67769600000000000e+07
    },
    /* 16777214 */
    {
        1.21543230923011700e-63, 5.22024201864511143e-54, 9.62964685207712960e-35,
        4.13590183017006213e-25, 7.62939225751109495e-06, 3.90624883524053534e-03,
        3.99999817212472886e+00, 3.19999497732139844e+01, 2.55997319560658525e+02,
        2.04783273324324227e+03, 3.27253652246982456e+04, 2.59434457346894662e+05,
        1.00621694177949021e+06, 6.17199139831178170e+06, 1.26597313574535716e+07,
        1.62529260000000075e+07, 1.67731180000000000e+07, 1.67769580000000000e+07
    },
    /* 15082603 */
    {
        9.82298962180288047e-64, 4.21894191745907802e-54, 7.78257418132130597e-35,
        3.34259015874689832e-25, 6.16599052016874108e-06, 3.15698714588672326e-03,
        3.23275437590726122e+00, 2.58620091390967453e+01, 2.06894417561625545e+02,
        1.65504939094220754e+03, 2.64517551029136412e+04, 2.09891694997857179e+05,
        8.16575685588646214e+05, 5.13336480662504770e+06, 1.10033654155580010e+07,
        1.45583150000001676e+07, 1.50785070000000000e+07, 1.50823470000000000e+07
    },
    /* 14986273 */
    {
        9.69791481108703163e-64, 4.16522269530128191e-54, 7.68347970702294475e-35,
        3.30002940611432092e-25, 6.08747978902901173e-06, 3.11678965155155231e-03,
        3.19159215049388845e+00, 2.55327118282773071e+01, 2.04260070593989951e+02,
        1.63397663226719487e+03, 2.61151435765585957e+04, 2.07231508480752498e+05,
        8.06367654055638355e+05, 5.07635187903902307e+06, 1.09097087114329021e+07,
        1.44619850000002030e+07, 1.49821770000000000e+07, 1.49860170000000000e+07
    },
    /* 14776336 */
    {
        9.42810913278675722e-64, 4.04934203884380436e-54, 7.46971762574649011e-35,
        3.20821929129359426e-25, 5.91812001988149620e-06, 3.03007744976589765e-03,
        3.10279887462500303e+00, 2.48223666728909436e+01, 1.98577376650443540e+02,
        1.58851938758362576e+03, 2.53890076205234654e+04, 2.01492261805796676e+05,
        7.84335037057878566e+05, 4.95288674782931432e+06, 1.07058149018839840e+07,
        1.42520480000003017e+07, 1.47722400000000000e+07, 1.47760800000000000e+07
    },
    /* 14196869 */
    {
        8.70314528971027262e-64, 3.73797243916420662e-54, 6.89534209398419660e-35,
        2.96152687883942827e-25, 5.46305284013487504e-06, 2.79708305378238405e-03,
        2.86421266221348869e+00, 2.29136797245160615e+01, 1.83308057120624454e+02,
        1.46637609822502554e+03, 2.34378018895664463e+04, 1.86065371296118683e+05,
        7.25048552277948707e+05, 4.61779125281785242e+06, 1.01446868737243451e+07,
        1.36725810000009108e+07, 1.41927730000000000e+07, 1.41966130000000000e+07
    },
    /* 12204240 */
    {
        6.43150420527001539e-64, 2.76231002257211870e-54, 5.09556260386307283e-35,
        2.18852747383125011e-25, 4.03712062080382464e-06, 2.06700575761862432e-03,
        2.11661365131384116e+00, 1.69328955058294497e+01, 1.35462286951825348e+02,
        1.08364216400000464e+03, 1.73228893695771148e+04, 1.37669261714004766e+05,
        5.38415595845002681e+05, 3.53292539626187785e+06, 8.23848823565938789e+06,
        1.16799520000407528e+07, 1.22001440000000000e+07, 1.22039840000000000e+07
    },
    /* 11017633 */
    {
        5.24164589759972754e-64, 2.25126977074033947e-54, 4.15285973017258180e-35,
        1.78363967259666233e-25, 3.29023445600991739e-06, 1.68460004130569592e-03,
        1.72503026241426105e+00, 1.38002320160382475e+01, 1.10401210801834779e+02,
        8.83168387150024387e+02, 1.41193736003445592e+04, 1.12282200585662198e+05,
        4.40082662240044388e+05, 2.94038767245387891e+06, 7.12661430867962260e+06,
        1.04933450003918260e+07, 1.10135370000000000e+07, 1.10173770000000000e+07
    },
    /* 9437505 */
    {
        3.84596615253128342e-64, 1.65182988466448099e-54, 3.04708831357108469e-35,
        1.30871446548116017e-25, 2.41415208102884383e-06, 1.23604586537905408e-03,
        1.26571085309146980e+00, 1.01256804873721595e+01, 8.10050383096763937e+01,
        6.48014349639423358e+02, 1.03611138831922271e+04, 8.24657129882121953e+04,
        3.24156550320632989e+05, 2.21947546481000213e+06, 5.68524343875118531e+06,
        8.91321700797987171e+06, 9.43340900000000000e+06, 9.43724900000000000e+06
    },
    /* 8390657 */
    {
        3.04006590453258966e-64, 1.30569836376521308e-54, 2.40858835538382027e-35,
        1.03448082158999336e-25, 1.90828029650285053e-06, 9.77039511733760911e-04,
        1.00048838056196132e+00, 8.00390259075751231e+00, 6.40309356878872933e+01,
        5.12229243608175807e+02, 8.19066683023702899e+03, 6.52277588009487954e+04,
        2.56891072309514391e+05, 1.78809403153571300e+06, 4.76371295024558529e+06,
        7.86636905876981001e+06, 8.38656100000000000e+06, 8.39040100000000000e+06
    },
    /* 8388608 */
    {
        3.03858131641597245e-64, 1.30506073802432296e-54, 2.40741214349811932e-35,
        1.03397564243176815e-25, 1.90734840543853551e-06, 9.76562383508887020e-04,
        9.99999801317883907e-01, 7.99999396006690677e+00, 6.39996668511303071e+01,
        5.11979106274727883e+02, 8.18666829515939844e+03, 6.51959881527814287e+04,
        2.56766914989349432e+05, 1.78728773698867904e+06, 4.76194118448516913e+06,
        7.86432005899994168e+06, 8.38451200000000000e+06, 8.38835200000000000e+06
    },
    /* 8303633 */
    {
        2.97733261180485959e-64, 1.27875461970161355e-54, 2.35888592027094511e-35,
        1.01313378825585727e-25, 1.86890197043808392e-06, 9.56877808790931330e-04,
        9.79842799195114300e-01, 7.83873807696676383e+00, 6.27096283547353366e+01,
        5.01659346659709513e+02, 8.02170245095559312e+03, 6.38851939022925071e+04,
        2.51643815255051391e+05, 1.75398342366120382e+06, 4.68858358349586092e+06,
        7.77934506938103493e+06, 8.29953700000000000e+06, 8.30337700000000000e+06
    },
    /* 6445069 */
    {
        1.79368505410408035e-64, 7.70381864670101568e-55, 1.42110370965965099e-35,
        6.10359395721248029e-26, 1.12591435658525644e-06, 5.76468150537344320e-04,
        5.90303350141551664e-01, 4.72242478267542509e+00, 3.77792690805288558e+01,
        3.02225885259077643e+02, 4.83334738231306892e+03, 3.85317788870130607e+04,
        1.52297025401436375e+05, 1.09355884627841157e+06, 3.15298493161437940e+06,
        5.92078340317591745e+06, 6.44097300000000000e+06, 6.44481300000000000e+06
    },
    /* 5471025 */
    {
        1.29249369610449219e-64, 5.55121815505495657e-55, 1.02401900603628891e-35,
        4.39812814140828746e-26, 8.11311442279305058e-07, 4.15391458426019348e-04,
        4.25360831402496142e-01, 3.40288541657277221e+00, 2.72230043153551051e+01,
        2.17778977519387723e+02, 3.48307701466327671e+03, 2.77819973005047868e+04,
        1.10006032571945238e+05, 8.02497636826934526e+05, 2.41479032500354247e+06,
        4.94675240411104914e+06, 5.46692900000000000e+06, 5.47076900000000000e+06
    },
    /* 5461601 */
    {
        1.28804481454968919e-64, 5.53211035427330002e-55, 1.02049423892798245e-35,
        4.38298938195209473e-26, 8.08518834066487105e-07, 4.13961643021164814e-04,
        4.23896700541549154e-01, 3.39117237605436062e+00, 2.71293003988329815e+01,
        2.17029372274540748e+02, 3.47109048311671313e+03, 2.76865308479067826e+04,
        1.09629930206165693e+05, 7.99877169687261223e+05, 2.40792627883238578e+06,
        4.93732868350143358e+06, 5.45750500000000000e+06, 5.46134500000000000e+06
    },
    /* 5000000 */
    {
        1.07952085348259170e-64, 4.63650676105773906e-55, 8.55284536172561161e-36,
        3.67341911163567920e-26, 6.77626222278107512e-07, 3.46944625790372989e-04,
        3.55271279996754563e-01, 2.84216929754907532e+00, 2.27372940653300759e+01,
        1.81894492427756745e+02, 2.90925341562651647e+03, 2.32109475844556837e+04,
        9.19864480283138982e+04, 6.76244582431662595e+05, 2.07902454915874335e+06,
        4.47574982779582217e+06, 4.99590400000000000e+06, 4.99974400000000000e+06
    },
    /* 4720129 */
    {
        9.62052468491602810e-65, 4.13198388920750452e-55, 7.62216493209018785e-36,
        3.27369491080454178e-26, 6.03890121950116545e-07, 3.09191742424983634e-04,
        3.16612330098731132e-01, 2.53289784792646122e+00, 2.02631320402621107e+01,
        1.62101808815417854e+02, 2.59273843912307711e+03, 2.06888306707860320e+04,
        8.20335711247183208e+04, 6.05859806423343602e+05, 1.88701706041535083e+06,
        4.19590551232236158e+06, 4.71603300000000000e+06, 4.71987300000000000e+06
    },
    /* 4598479 */
    {
        9.13102296289999889e-65, 3.92174450046805166e-55, 7.23434171226120578e-36,
        3.10712610622505210e-26, 5.73163600862704501e-07, 2.93459763629244023e-04,
        3.00502784877568652e-01, 2.40402154589327210e+00, 1.92321254470970260e+01,
        1.53854000743080690e+02, 2.46084059619524533e+03, 1.96376437319819379e+04,
        7.78830134114269749e+04, 5.76361321148565039e+05, 1.80542466236221301e+06,
        4.07427236013673665e+06, 4.59438300000000000e+06, 4.59822300000000000e+06
    },
    /* 4514873 */
    {
        8.80201481185765059e-65, 3.78043657558362023e-55, 6.97367459966819779e-36,
        2.99517043385208020e-26, 5.52511424504064165e-07, 2.82885849334287552e-04,
        2.89675097340006849e-01, 2.31740008485763216e+00, 1.85391562717557470e+01,
        1.48310408165256945e+02, 2.37218721144947949e+03, 1.89310433056085276e+04,
        7.50922424384496408e+04, 5.56476519408195047e+05, 1.75003032936007436e+06,
        3.99068042602826888e+06, 4.51077700000000000e+06, 4.51461700000000000e+06
    },
    /* 4216423 */
    {
        7.67678466448147999e-65, 3.29715390723822894e-55, 6.08217542984550923e-36,
        2.61227445597212045e-26, 4.81879583396028819e-07, 2.46722346689160995e-04,
        2.52643672927461205e-01, 2.02114881826249349e+00, 1.61691543761076666e+01,
        1.29350920164308604e+02, 2.06897994841936315e+03, 1.65139961617354602e+04,
        6.55409147975342930e+04, 4.88100916845553555e+05, 1.55700132055291533e+06,
        3.69230361198300030e+06, 4.21232700000000000e+06, 4.21616700000000000e+06
    },
    /* 4194304 */
    {
        7.59645238547202323e-65, 3.26265145612235253e-55, 6.01852964128048457e-36,
        2.58493879793062928e-26, 4.76837044516251121e-07, 2.44140566782865192e-04,
        2.49999930461255154e-01, 1.99999888738057052e+00, 1.59999554953052812e+01,
        1.27997365357353743e+02, 2.04733300825732044e+03, 1.63414126607763610e+04,
        6.48586183619030489e+04, 4.83196861208001501e+05, 1.54299802768340637e+06,
        3.67019187768841069e+06, 4.19020800000000000e+06, 4.19404800000000000e+06
    },
    /* 4000000 */
    {
        6.90893311684184468e-65, 2.96736417870870697e-55, 5.47382075781328512e-36,
        2.35098811389739960e-26, 4.33680760573953185e-07, 2.22044549405662773e-04,
        2.27373609983355179e-01, 1.81898839734530293e+00, 1.45518762974392430e+01,
        1.16413034003141178e+02, 1.86206657745167763e+03, 1.48642188911844787e+04,
        5.90168968299262124e+04, 4.41096638730170089e+05, 1.42185603096995712e+06,
        3.47596677852119505e+06, 3.99590400000000000e+06, 3.99974400000000000e+06
    },
    /* 3981553 */
    {
        6.84535550514410596e-65, 2.94005780240874949e-55, 5.42344938429471275e-36,
        2.32935377370571273e-26, 4.29689929206757446e-07, 2.20001243745771501e-04,
        2.25281265106172607e-01, 1.80224964497290951e+00, 1.44179667037433958e+01,
        1.15341784471186955e+02, 1.84493404804906459e+03, 1.47276033582964737e+04,
        5.84764753082058160e+04, 4.37191522377733258e+05, 1.41053273133602901e+06,
        3.45752890244734008e+06, 3.97745700000000000e+06, 3.98129700000000000e+06
    },
    /* 3469497 */
    {
        5.19785334334943400e-65, 2.23246101190900781e-55, 4.11816369412201186e-36,
        1.76873783858285884e-26, 3.26274542418221493e-07, 1.67052565712777593e-04,
        1.71061821672631342e-01, 1.36849425850745465e+00, 1.09479339161807978e+01,
        8.75821816252248908e+01, 1.40096122943031264e+03, 1.11865973776804603e+04,
        4.44589238065494865e+04, 3.35240937339222815e+05, 1.10925791919939918e+06,
        2.94590981907640956e+06, 3.46540100000000000e+06, 3.46924100000000000e+06
    },
    /* 2796417 */
    {
        3.37671825984804601e-65, 1.45028944938533875e-55, 2.67531183056124863e-36,
        1.14903768188624562e-26, 2.11960040488029904e-07, 1.08523540727069068e-04,
        1.11128102763280903e-01, 8.89024657235948701e-01, 7.11218670620169569e+00,
        5.68968183484790444e+01, 9.10163898031904523e+02, 7.27026311537105084e+03,
        2.89302976804814243e+04, 2.20626239906953182e+05, 7.55430265292525059e+05,
        2.27465918879699614e+06, 2.79232100000000000e+06, 2.79616100000000000e+06
    },
    /* 2396744 */
    {
        2.48047143920984062e-65, 1.06535437100683176e-55, 1.96523194297708407e-36,
        8.44060692414111294e-27, 1.55701715756405132e-07, 7.97192784655151597e-05,
        8.16325392969082797e-02, 6.53060210574274436e-01, 5.22447504133784690e+00,
        4.17953751659456785e+01, 6.68609402176202252e+02, 5.34191798810462478e+03,
        2.12726697966660395e+04, 1.63326698532949667e+05, 5.71039962053837837e+05,
        1.87787878976813331e+06, 2.39264800000000000e+06, 2.39648800000000000e+06
    },
    /* 2098177 */
    {
        1.90096951102133711e-65, 8.16460188052975446e-56, 1.50610321353860109e-36,
        6.46866404654879610e-27, 1.19325790165487525e-07, 6.10948045635459623e-05,
        6.25610786307022049e-02, 5.00488559404961619e-01, 4.00390401824189190e+00,
        3.20309469002191776e+01, 5.12416921058289972e+02, 4.09466699542457309e+03,
        1.63148862712246882e+04, 1.25897567119276093e+05, 4.47225202517700847e+05,
        1.58347287791373348e+06, 2.09408100000000000e+06, 2.09792100000000000e+06
    },
    /* 2097152 */
    {
        1.89911264358405187e-65, 8.15662669561360700e-56, 1.50463205158771428e-36,
        6.46234545408261769e-27, 1.19209232707357876e-07, 6.10351271449853099e-05,
        6.24999689559159743e-02, 4.99999682108684340e-01, 3.99999300640047295e+00,
        3.19996592233267698e+01, 5.11916432816754536e+02, 4.09066992542314756e+03,
        1.62989912696615120e+04, 1.25777098836656849e+05, 4.46821820522652706e+05,
        1.58246663305044221e+06, 2.09305600000000000e+06, 2.09689600000000000e+06
    },
    /* 1271626 */
    {
        6.98247791753670586e-66, 2.99895143008623366e-56, 5.53208895202860154e-37,
        2.37601411275257565e-27, 4.38297242534678273e-08, 2.24408188175120292e-05,
        2.29793981925642821e-02, 1.83835170037565776e-01, 1.47068036811238745e+00,
        1.17653794451473974e+01, 1.88228655326640251e+02, 1.50478955000098654e+03,
        6.00493221828217247e+03, 4.69964688955476740e+04, 1.74675738335436967e+05,
        7.93705775574441534e+05, 1.26753000000000000e+06, 1.27137000000000000e+06
    },
    /* 1180417 */
    {
        6.01674571488324041e-66, 2.58417260737716580e-56, 4.76695707305772932e-37,
        2.04739247302188301e-27, 3.77677249682731562e-08, 1.93370751835450871e-05,
        1.98011647667272750e-02, 1.58409305733226813e-01, 1.26727365222838628e+00,
        1.01381384252463871e+01, 1.62196284074367895e+02, 1.29673859731428774e+03,
        5.17557281139463612e+03, 4.05690452754900689e+04, 1.51559237337625702e+05,
        7.11307437578365323e+05, 1.17632100000000000e+06, 1.18016100000000000e+06
    },
    /* 1048576 */
    {
        4.74777934504035996e-66, 2.03915570155726458e-56, 3.76157833530725135e-37,
        1.61558559314867667e-27, 2.98022939659853163e-08, 1.52587745104367425e-05,
        1.56249849436188217e-02, 1.24999870856632000e-01, 9.99998410544928107e-01,
        7.99995168077293606e+00, 1.27989461928571330e+02, 1.02333268407003743e+03,
        4.08535025830558106e+03, 3.20958386865916218e+04, 1.20799142289413823e+05,
        5.95242529642230948e+05, 1.04448000000000000e+06, 1.04832000000000000e+06
    },
    /* 1000000 */
    {
        4.31807995946294477e-66, 1.85460122074063535e-56, 3.42113540777918151e-37,
        1.46936646915992086e-27, 2.71050272070828090e-08, 1.38777739298982540e-05,
        1.42108403697154325e-02, 1.13686715418339940e-01, 9.09493240826389937e-01,
        7.27591504542061607e+00, 1.16406170946493603e+02, 9.30743673031597268e+02,
        3.71605194956770447e+03, 2.92188944778244804e+04, 1.10274089241209091e+05,
        5.53554744840516942e+05, 9.95904000000000000e+05, 9.99744000000000000e+05
    },
    /* 819841 */
    {
        2.90235045358949550e-66, 1.24655002796976490e-56, 2.29947893410337365e-37,
        9.87618681981492889e-28, 1.82183490689266710e-08, 9.32779472321984348e-06,
        9.55166172246109217e-03, 7.64132896251342869e-02, 6.11306051109687054e-01,
        4.89043139187867482e+00, 7.82422349713714453e+01, 6.25659192034058037e+02,
        2.49882041253832767e+03, 1.97089496950203138e+04, 7.51500479695295217e+04,
        4.05315292462697893e+05, 8.15745000000000000e+05, 8.19585000000000000e+05
    },
    /* 652545 */
    {
        1.83870213969147930e-66, 7.89716555706012712e-57, 1.45676991938802090e-37,
        6.25677916156810610e-28, 1.15417203919164522e-08, 5.90936084062561679e-06,
        6.05118546342795372e-03, 4.84094816125079305e-02, 3.87275718825497939e-01,
        3.09819716985184357e+00, 4.95688012285943671e+01, 3.96409870457700265e+02,
        1.58371435214666167e+03, 1.25273157680588301e+04, 4.82278663969549234e+04,
        2.79276527717245917e+05, 6.48449000000000000e+05, 6.52289000000000000e+05
    },
    /* 524801 */
    {
        1.18926762015466819e-66, 5.10786553475605035e-57, 9.42234882825664415e-38,
        4.04686800688662073e-28, 7.46515384231198445e-09, 3.82215876724521482e-06,
        3.91389055821865072e-03, 3.13111233760198990e-02, 2.50488917265499822e-01,
        2.00390687460218908e+00, 3.20612857504726705e+01, 2.56417175606829119e+02,
        1.02466699434609745e+03, 8.12310498202530835e+03, 3.15045400686032553e+04,
        1.93198962659155397e+05, 5.20705000000000000e+05, 5.24545000000000000e+05
    },
    /* 401857 */
    {
        6.97321585851295025e-67, 2.99497340602616845e-57, 5.52475079285309336e-38,
        2.37286239738541065e-28, 4.37715853666972486e-09, 2.24110517076658296e-06,
        2.29489168613654978e-03, 1.83591329998224681e-02, 1.46873032685309740e-01,
        1.17498225743608220e+00, 1.87991664504370917e+01, 1.50360504164546711e+02,
        6.00992138052254290e+02, 4.77454013471333201e+03, 1.86505860938960723e+04,
        1.21176669942356806e+05, 3.97761000000000000e+05, 4.01601000000000000e+05
    },
    /* 264097 */
    {
        3.01173257048041585e-67, 1.29352928945114011e-57, 2.38614037543525460e-38,
        1.02483948761595803e-28, 1.89049517446831162e-09, 9.67933529325415291e-07,
        9.91163931551744364e-04, 7.92931131353941630e-03, 6.34344816203459005e-02,
        5.07475284133261262e-01, 8.11944852670449713e+00, 6.49462697901977464e+01,
        2.59657344516898661e+02, 2.06775748649864772e+03, 8.14269081216647010e+03,
        5.66232434728111548e+04, 2.60001000000000000e+05, 2.63841000000000000e+05
    },
    /* 204800 */
    {
        1.81112697232874206e-67, 7.77873111505544409e-58, 1.43492262097629106e-38,
        6.16294572938377368e-29, 1.13686282610103304e-09, 5.82073766962628089e-07,
        5.96043536214395245e-04, 4.76834822495310166e-03, 3.81467816548533359e-02,
        3.05173987973646754e-01, 4.88271104998955341e+00, 3.90573427578099199e+01,
        1.56169795671348624e+02, 1.24492319174046884e+03, 4.91958032892884057e+03,
        3.52628737812490363e+04, 2.00704000000000000e+05, 2.04544000000000000e+05
    },
    /* 200000 */
    {
        1.72722507485033383e-67, 7.41837520931333590e-58, 1.36844868928954633e-38,
        5.87744236675266698e-29, 1.08419675147463808e-09, 5.55108736753989574e-07,
        5.68431345360095224e-04, 4.54745070256641366e-03, 3.63796017604134173e-02,
        2.91036567035938998e-01, 4.65651731179381212e+00, 3.72480912910018702e+01,
        1.48936880685972909e+02, 1.18736413772828405e+03, 4.69345257857060551e+03,
        3.37256310720094916e+04, 1.95904000000000000e+05, 1.99744000000000000e+05
    },
    /* 102774 */
    {
        4.56093001325520124e-68, 1.95890452462759358e-58, 3.61354104306368883e-39,
        1.55200406027122712e-29, 2.86294217011813689e-10, 1.46582639109909510e-07,
        1.50100622302544283e-04, 1.20080497023619128e-03, 9.60643923810312883e-03,
        7.68514803825075948e-02, 1.22961449148191515e+00, 9.83636673154418517e+00,
        3.93379364327392551e+01, 3.14142047803753769e+02, 1.24891387725365462e+03,
        9.44593016329059901e+03, 9.86780000000517612e+04, 1.02518000000000000e+05
    },
    /* 100000 */
    {
        4.31804109670444684e-68, 1.85458452931295726e-58, 3.42110461752972125e-39,
        1.46935324484847411e-29, 2.71047832615944429e-10, 1.38776490299235408e-07,
        1.42107125931920287e-04, 1.13685699991618186e-03, 9.09485551682193138e-03,
        7.27588132541049926e-02, 1.16413254204269756e+00, 9.31255441700961661e+00,
        3.72432805975374706e+01, 2.97429023684080164e+02, 1.18266355295424069e+03,
        8.95817783366734693e+03, 9.59040000001018925e+04, 9.97440000000000000e+04
    },
    /* 77163 */
    {
        2.57100957639565332e-68, 1.10424020483221446e-58, 2.03696364544404734e-39,
        8.74869224032312274e-30, 1.61384886736889072e-10, 8.26290620092283361e-08,
        8.46121594356573939e-05, 6.76897272021500683e-04, 5.41517795449147563e-03,
        4.33214094483818091e-02, 6.93138659749164665e-01, 5.54487683849644686e+00,
        2.21763200560975164e+01, 1.77172840383531820e+02, 7.05445676326827083e+02,
        5.40962011023344166e+03, 7.30670000269061129e+04, 7.69070000000000000e+04
    },
    /* 50643 */
    {
        1.10744301397987420e-68, 4.75643152722723048e-59, 8.77406750868841857e-40,
        3.76843330027129536e-30, 6.95153246489491803e-11, 3.55918462202453374e-08,
        3.64460505120626550e-05, 2.91568403117305078e-04, 2.33254716226988625e-03,
        1.86603732873723421e-02, 2.98564872499666734e-01, 2.38845326899687205e+00,
        9.55291197889362387e+00, 7.63560630702938568e+01, 3.04504893070908849e+02,
        2.36897008846858444e+03, 4.65470174614963616e+04, 5.03870000000000000e+04
    },
    /* 6 */
    {
        1.29542528326416669e-76, 5.56380922603113208e-67, 1.02634164867540313e-47,
        4.40810381558357815e-38, 8.13151629364128326e-19, 4.16333634234433703e-16,
        4.26325641456043956e-13, 3.41060513164744692e-12, 2.72848410531216727e-11,
        2.18278728421267612e-10, 3.49245965372384226e-09, 2.79396771690754164e-08,
        1.11758707843634397e-07, 8.94069600576588975e-07, 3.57627754965526357e-06,
        2.86101567327154416e-05, 3.66091750036190520e-03, 5.82894668923472636e-02
    },
};

static void printdouble( const int width, const double value ) {
    if (width < 10) {
        printf("%.*s|", width - 1, "----------");
    } else if (value == 0.0) {
        printf(" %*.3f |", width - 2, value);
    } else if (value < 1.0e-100) {
        printf(" %.*e |", width - 9, value);
    } else if (value < 1.0e-6) {
        printf(" %.*e  |", width - 9, value);
    } else if (value < 1.0) {
        printf("  %*.*f |", width - 3, width - 5, value);
    } else if (value < 1.0e6) {
        printf(" %*.3f |", width - 2, value);
    } else {
        printf(" %*.1f   |", width - 4, value);
    }
}

void ReportCollisionEstimates( void ) {
    const int keys[] = {
        149633745, 86536545, 75498113, 56050289, 49925029, 44251425,
         43691201, 33558529, 33554432, 26977161, 22370049, 18877441,
         18616785, 17676661, 16777216, 16777214, 15082603, 14986273,
         14776336, 14196869, 12204240, 11017633,  9437505,  8390657,
          8388608,  8303633,  6445069,  5471025,  5461601,  5000000,
          4720129,  4598479,  4514873,  4216423,  4194304,  4000000,
          3981553,  3469497,  2796417,  2396744,  2098177,  2097152,
          1271626,  1180417,  1048576,  1000000,   819841,   652545,
           524801,   401857,   264097,   204800,   200000,   102774,
           100000,    77163,    50643,        6
    };
    const int bits[] = { 256, 224, 160, 128, 64, 55, 45, 42, 39, 36, 32, 29, 27, 24, 22, 19, 12, 8 };

    printf("EstimateNbCollisions:\n");
    printf(
            "  # keys   : bits|    True answer     |   A: _fwojcik()    |   B: _previmpl()   |   C: _Demerphq()   |    Error A   |    Error B   |    Error C   |\n");
    printf(
            "---------------------------------------------------------------------------------------------------------------------------------------------------\n");
    for (int i = 0; i < sizeof(keys) / sizeof(keys[0]); i++) {
        const int key = keys[i];
        for (int j = 0; j < sizeof(bits) / sizeof(bits[0]); j++) {
            const int bit = bits[j];
            printf(" %9d : %3d |", key, bit);
            printdouble(20, realcoll[i][j]);
            for (int k = 0; k < COLLISION_ESTIMATORS; k++) {
                printdouble(20, EstimateNbCollisionsCand(key, bit, k));
            }
            for (int k = 0; k < COLLISION_ESTIMATORS; k++) {
                double delta    = EstimateNbCollisionsCand(key, bit, k) - realcoll[i][j];
                double deltapct = delta / realcoll[i][j] * 100.0;
                if (deltapct > 9999.999) {
                    deltapct = 9999.999;
                }
                printf(" %+11.5f%% |", deltapct);
            }
            printf("\n");
        }
    }
}

//-----------------------------------------------------------------------------

/*
 * Compute the lowest number of hash bits (n) such that there are
 * fewer than (2**n)*log(2**n) hashes, for a given hash count.
 *
 * This may validly return a value exceeding the number of hash bits
 * that exist for the hash being tested!
 */
int GetNLogNBound( unsigned nbH ) {
    int nbHBits;

    for (nbHBits = 1; nbHBits <= 255; nbHBits++) {
        if (nbH < (log(2.0) * nbHBits * exp2(nbHBits))) {
            break;
        }
    }
    return nbHBits - 1;
}

/*
 * What SMHasher3 frequently reports on is the worst result across some
 * number of tests. If we compute the CDF/p-value of each test and
 * consider only those, then the tests become statistically identical,
 * since CDFs are continuous ~Uniform(0,1). Assuming sufficient
 * independence also, the CDF of the maximum of N values is equal to
 * the CDF of a single value raised to the Nth power, so we can just
 * raise the p-value itself to the power of the number of tests.
 *
 * The p-values in SMHasher3 are usually stored in variables as 1.0-p,
 * so that p-values very close to 1 (which are in the vicinity of
 * failing results) can be kept as accurate as possible in the face of
 * floating-point representation realities. This means we can't just
 * use pow(), but this alternate formulation does the same thing for
 * values in 1-p space.
 */
double ScalePValue( double p_value, unsigned testcount ) {
    return -expm1(log1p(-p_value) * testcount);
}

/*
 * This is exactly the same as ScalePValue, but for 2**N tests.
 */
double ScalePValue2N( double p_value, unsigned testbits ) {
    return -expm1(log1p(-p_value) * exp2(testbits));
}

/*
 * SMHasher3 reports p-values by displaying how many powers of 2 the
 * improbability is. This is the nicest way of summarizing the p-value
 * I've found. And since the really, truly most important result of
 * these tests is "does a hash pass or fail", and perhaps how close to
 * the line it is, the precise p-value is generally better left
 * unprinted.
 *
 * This is not a percentage or a ratio, and there is no standard unit
 * of log probability that I can find, so I've semi-arbitrarily chosen
 * the caret (^) to display these values, as that can indicate
 * exponentiation, and the p-value is no less than 1/(2**logp_value).
 */
int GetLog2PValue( double p_value ) {
    return (log2(p_value) <= -99.0) ? 99 : -ceil(log2(p_value));
}

/*
 * Given a mean and standard deviation, return (1.0 - p) for the given
 * random normal variable.
 */
double GetNormalPValue( const double mu, const double sd, const double variable ) {
    double stdvar  = (variable - mu) / sd;
    double p_value = erfc(stdvar / sqrt(2.0)) / 2.0;

    return p_value;
}

/*
 * A helper function for the Peizer and Pratt approximation below.
 */
static double GFunc_PeizerPratt( const double x ) {
    if (x < 0.0) {
        return NAN;
    }
    if (x == 0.0) {
        return 1.0;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x > 1.0) {
        return -GFunc_PeizerPratt(1.0 / x);
    }
    return (1.0 - x * x + 2 * x * log(x)) / ((1.0 - x) * (1.0 - x));
}

/*
 * Assume that m balls are i.i.d. randomly across n bins, with m >=
 * n*log(n). Then, the number of balls in any given bin tends to have
 * about log(n) balls and follows a binomial distribution. That is, if
 * Xi is the number of balls in bin i, then Xi ~ Bin(m, 1/n).
 *
 * But we aren't reporting on Xi, we are reporting on Xm = max{i=1..n;
 * Xi}. All the Xi are from identical distributions, and are actually
 * sufficiently independent in the random case that we can use the
 * usual {CDF(Xm)} = {CDF(Xi)}**n.
 *
 * The best non-iterative approximation to the Binomial distribution
 * CDF that I've found is the Peizer and Pratt transformation into a
 * standard normal distribution. We use that to find a p-value for Xi.
 * NB: "best" here is akin to "closest to p-values obtained through
 * simulation for Xm in the extreme tails", and not "least error
 * compared to actual overall binomial distribution values".
 *
 * Thanks to the paper:
 *   "APPROXIMATIONS TO THE BINOMIAL", by MYRTLE ANNA BRUCE
 *   https://core.ac.uk/download/pdf/33362622.pdf
 */
double EstimatedBinomialPValue( const unsigned long nbH, const int nbBits, const int maxColl ) {
    const double s     = maxColl + 1;
    const double n     = nbH;
    const double t     = nbH - maxColl;
    const double p     = exp2(-nbBits);
    const double q     = 1.0 - p;

    const double d1    = s + 1.0 / 6.0 - p * (n + 1.0 / 3.0);
    const double d2    = d1 + 0.02 * (q / (s + 0.5) - p / (t + 0.5) + (q - 0.5) / (n + 1));

    const double num   = 1.0 + q * GFunc_PeizerPratt(s / (n * p)) + p * GFunc_PeizerPratt(t / (n * q));
    const double denom = (n + 1.0 / 6.0) * p * q;
    const double z2    = d2 * sqrt(num / denom);

    // (1.0 - p) for one hash bin
    double p_value = GetNormalPValue(0.0, 1.0, z2);
    // fprintf(stderr, "Pr(Xi > %ld; %d, %d) ~= 1.0 - N(%f)\n", nbH, nbBits, maxColl, z2);

    // (1.0 - p) across all 2**nbBits hash bins
    double pm_value = ScalePValue2N(p_value, nbBits);

    // fprintf(stderr,"Pr(Xm > %ld; %d, %d) ~= 1.0-((1.0-%e)**(2**n)) == %.12f\n", nbH, nbBits, maxColl, p_value,
    // pm_value, pm_value);

    return pm_value;
}

/*
 * For estimating the maximum value, we could get the normal value
 * with p=0.5 and back-convert, but the C standard library doesn't
 * have an inverse erf(), and I don't want to add an external
 * dependency just for this.
 *
 * This function computes an estimate of an upper bound on the number
 * of balls in the most-occupied bin. This set of formulas comes from:
 *
 * '"Balls into Bins" - A Simple and Tight Analysis', by
 *   Martin Raab and Angelika Steger
 *   http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.399.3974
 *
 * The adjustments for calculating the value that corresponds to the
 * 50th-percentile for a given nbBits were computed via linear
 * regression from Monte Carlo experiments by fwojcik [N ~= 80,000,000].
 */
double EstimateMaxCollisions( const unsigned long nbH, const int nbBits ) {
    double alpha = -expm1(-0.128775055 * nbBits - 0.759110989);
    double m     = (double)nbH - 16;
    double n     = exp2(nbBits);
    double logn  = nbBits * log(2);

    return (m / n) + alpha * sqrt(2.0 * (m / n) * logn);
}

/*
 * While computing p-values for Poisson distributions is generally
 * straightforward, it is also iterative and can require special care
 * due to floating-point considerations, especially in the long tail
 * of the distribution. Instead, this computes an upper bound on the
 * p-value using a single calculation. This is taken from:
 *
 * "Sharp Bounds on Tail Probabilities for Poisson Random Variables", by
 *   Peter Harremos
 *   https://helda.helsinki.fi/bitstream/handle/10138/229679/witmse_proc_17.pdf
 *
 * Similar to other places in SMHasher3, this returns 1.0-p, so the
 * closer to 0 the worse the result. This also doesn't bother
 * computing real p-values for lower-than-expected collision counts,
 * since that is never a failure condition.
 */
double BoundedPoissonPValue( const double expected, const uint64_t collisions ) {
    if (collisions < expected) {
        return 1.0;
    }
    double x            = (double)collisions - 0.5;
    double g_over_root2 = sqrt(x * log(x / expected) + expected - x);
    double p_lbound     = erfc(g_over_root2) / 2.0;
    return p_lbound;
}

//-----------------------------------------------------------------------------
// Distribution score
//
// Randomly distributing m balls into n bins is a well-studied
// statistical model, relevant to a wide range of real world
// problems. It is exactly analogous to hashing k keys into n
// bins. The count of balls in a bin approximately follows a Poisson
// distribution, if the number of balls and bins are large enough.
//
// The previous version of this test was intended to compare the total
// set of key counts in each hash bin against a truly random Poisson
// distribution. It computed the Root Mean Square (RMS) of the actual
// key counts, and then computed how many bins would be needed to get
// that same RMS value assuming a random hash, finally comparing the
// two to come up with a single score value. For this score, less than
// 0 meant flatter/more even than random, 0.000 meant exactly random,
// and 1.000 (percent, as it happens) was considered a failure.
//
// This was very clever, but one of the key goals of the test turns
// out not to have been met. The previous comments said: "This makes
// for a nice uniform way to rate a distribution that isn't dependent
// on the number of bins or the number of keys". Unfortunately, it
// turns out that while a score of 0 did hold the desired meaning
// across all bin/key counts, the _variance_ of the score _was_
// dependent on the number of bins. This means that higher bin counts
// typically had higher scores from this test, even if the
// distributions were closer to the random ideal. And since only the
// highest score gets reported on, this also distorted which bit
// widths were reported as having the highest bias.
//
// I tried applying some corrections to the score with the goal of
// keeping this test. Multiplying the score by (keycount/bincount)
// comes close to having it be independent of the test sizes, but not
// close enough. The resulting score is very accurate when the bin
// counts are close to random, but it under-reports failures, and the
// worse the failure the more inaccurate the adjusted score was. A
// further correction to the score, to accurately report failures,
// seems to require bin- and hash-dependent constants for both
// score**2 and score**3 terms at the least.
//
// Rather than go down that complicated route, I changed this test to
// compute Root Mean Square Error (RMSE) across the bin counts. A
// truly random Poisson distribution will have an expected MSE of
// lambda (keycount/bincount), and multiplying the ratio of
// actual/expected by a factor of sqrt(2.0 * bincount) makes the score
// be a standard normal variable (E[score] = 0, Var[score] = 1)
// independent of bincount and keycount.
//
// The way the RMSE is calculated is a little odd. What we want is
// sumN{(Bi - lambda)**2}. But Bi values are integers, and doing all
// that math in a loop is expensive. So that formula gets rearranged:
//
// sumN{(Bi - lambda)**2}
// sumN{(Bi**2 - 2 * Bi * lambda + lambda**2)}
// sumN{(Bi**2)} - 2 * sumN{(Bi * lamba)} + sumN{(lambda**2)}
// sumN{(Bi**2)} - 2 * lambda * sumN{(Bi)} + N * (lambda**2)
// sumN{(Bi**2)} - 2 * lambda * M + N * (lambda**2)
// sumN{(Bi**2)} - 2 * M / N * M + N * M**2 / N**2
// sumN{(Bi**2)} - 2 * M**2 / N + M**2 / N
// sumN{(Bi**2)} - M**2 / N
// sumN{(Bi**2)} - M * lambda
//
// NB: bincount must be a non-zero multiple of 8!
double calcScore( const unsigned * bins, const int bincount, const int keycount ) {
    const double n      = bincount;
    const double k      = keycount;
    const double lambda = k / n;

    uint64_t sumsq      = 0;

    assume(bincount >= 8);
    for (int i = 0; i < (bincount >> 3) << 3; i++) {
        sumsq += (uint64_t)bins[i] * (uint64_t)bins[i];
    }

    double sumsqe        = (double)sumsq - lambda * k;
    double rmse          = sqrt(sumsqe / n);
    double rmse_ratio_m1 = (rmse - sqrt(lambda)) / sqrt(lambda); // == rmse/sqrt(lambda) - 1.0
    double score         = (rmse_ratio_m1) * sqrt(2.0 * n);

    return score;
}

// Convert the score from calcScore back into (rmse/sqrt(lambda) -
// 1.0), to show the user something like the previous report.
double normalizeScore( double score, int scorewidth, int tests ) {
    if (score <= 0) {
        return 0.0;
    }

    // Never return a result higher than this, as a precise value
    // would be visually cluttered and not really meaningful.
    const double maxresult = 999.9;

    double result = score / sqrt(2.0 * scorewidth);

    if (result > maxresult) {
        return maxresult;
    }

    return result;
}

//----------------------------------------------------------------------------
// Return the chi-square value for a chi-square test of independence on a 2x2
// contingency matrix. Note that there is only one (1) degree of freedom here.
//
// This formulation works better than the normal chi-square test, and much better
// than raw bias calculations, when the individual bits might themselves be biased
// (e.g. bit X not being a 50/50 coin flip might throw off the result for
// independence between bits X and Y).
//
// While I don't know that this is the very best test for this, it performs very well
// in my tests. Fisher's exact test can't be used because the row and column sums
// (aka the margin values) aren't fixed. The same is true of Barnard's exact test and
// Boschloo's test. We might be able to get a p-value from the binomial approximation
// above, since we know these are being compared against Bernoulli trials with p =
// 0.5 exactly. That sounds complicated, tho. :) We might also be able to use a
// G-test for mutual information.

double ChiSqIndepValue( const uint32_t * boxes, size_t total ) {
    const double   N         = (double)total;
    const uint64_t colsum[2] = { boxes[0] + boxes[1], boxes[2] + boxes[3] };
    const uint64_t rowsum[2] = { boxes[0] + boxes[2], boxes[1] + boxes[3] };
    const double   expect[4] = {
        colsum[0] * rowsum[0] / N,
        colsum[0] * rowsum[1] / N,
        colsum[1] * rowsum[0] / N,
        colsum[1] * rowsum[1] / N,
    };
    double chisq = 0.0;

    for (int i = 0; i < 4; i++) {
        if (expect[i] < 10.0) {
            // printf("chisq of %d %d %d %d is INF, chi is INF, cdf is INF 99", boxes[0], boxes[1], boxes[2], boxes[3]);
            return total;
        }
        chisq += ((double)boxes[i] - expect[i]) * ((double)boxes[i] - expect[i]) / expect[i];
    }
#if 0
    printf("chisq of %d %d %d %d vs. %d %d %d %d is %f, chi is %f, cdf is %e %2d", boxes[0],
            boxes[1], boxes[2], boxes[3], (int)expect[0], (int)expect[1], (int)expect[2],
            (int)expect[3], chisq, sqrt(chisq), cdf, GetLog2PValue(cdf));
#endif
    return chisq;
}

double ChiSqPValue( double chisq, uint64_t dof ) {
    if (dof == 1) {
        // Chi-sq CDF for 1 degree-of-freedom is P(x) = 1 - 2 * Q(sqrt(x)) where
        // Q(y) = 1 - StandardNormalCDF(y).
        //
        // Since we want this result in our usual "1.0 - p" format, and we
        // already have a function for 1 - Q(y), this is easy to compute.
        return 2.0 * GetNormalPValue(0.0, 1.0, sqrt(chisq));
    }

    double ddof = (double)dof;

    if (chisq <= ddof) {
        return 1.0;
    }

    return exp(-ddof / 2.0 * (chisq / ddof - 1.0 - log(chisq / ddof)));
}
